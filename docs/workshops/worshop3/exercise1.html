<!DOCTYPE html><html><head><title>vc | Path Tracing</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><meta name="robots" content="index,follow"><meta name="theme-color" content="#212121"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><link href="https://fonts.googleapis.com/css?family=Hind:400,700&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:300,400&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/icon?family=Material+Icons%7CMaterial+Icons+Outlined&amp;display=swap" rel="stylesheet"><style>
      body, input, button {
        font-family: 'Hind', sans-serif;
      }

      code, .hljs {
        font-family: 'Source Code Pro', 'Courier New', Courier, monospace;
      }

      .icon-font {
        font-family: 'Material Icons';
        font-weight: normal;
        font-style: normal;
        font-size: 24px;  /* Preferred icon size */
        display: inline-block;
        line-height: 1;
        text-transform: none;
        letter-spacing: normal;
        word-wrap: normal;
        white-space: nowrap;
        direction: ltr;
      
        /* Support for all WebKit browsers. */
        -webkit-font-smoothing: antialiased;
        /* Support for Safari and Chrome. */
        text-rendering: optimizeLegibility;
      
        /* Support for Firefox. */
        -moz-osx-font-smoothing: grayscale;
      
        /* Support for IE. */
        font-feature-settings: 'liga';
      }

      .icon-font.outline {
        font-family: 'Material Icons Outlined';
      }
    </style><link href="/vc/docs/assets/codedoc-styles.css" rel="stylesheet"><script async="" defer="" src="/vc/docs/assets/codedoc-bundle.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous"></head><body><div class="header-0-0-5"><script async="" defer="" src="https://buttons.github.io/buttons.js"></script><a class="github-button" data-color-scheme="no-preference: light; light: light; dark: dark;" data-icon="octicon-star" data-show-count="false" data-size="large" href="https://github.com/afsanchezsa/vc/">Star</a><br><br><a class="watermark-0-0-4" href="https://github.com/CONNECT-platform/codedoc" target="_blank">Created With<svg viewBox="0 0 536 296" version="1.1" xmlns="http://www.w3.org/2000/svg"><g id="codedoc" transform="translate(-244.000000, -364.000000)" fill-rule="nonzero"><path d="M580,532 C615.346224,532 644,560.653776 644,596 C644,631.346224 615.346224,660 580,660 C544.653776,660 516,631.346224 516,596 C516,560.653776 544.653776,532 580,532 Z M716,532 C751.346224,532 780,560.653776 780,596 C780,631.346224 751.346224,660 716,660 L692,660 C687.581722,660 684,656.418278 684,652 C684,647.581722 687.581722,644 692,644 L716,644 C742.509668,644 764,622.509668 764,596 C764,569.490332 742.509668,548 716,548 L692,548 C687.581722,548 684,544.418278 684,540 C684,535.581722 687.581722,532 692,532 L716,532 Z M468,532 C472.418278,532 476,535.581722 476,540 L476,652 C476,656.418278 472.418278,660 468,660 L444,660 C408.653776,660 380,631.346224 380,596 C380,560.653776 408.653776,532 444,532 L468,532 Z M332,532 C336.418278,532 340,535.581722 340,540 L340,652 C340,656.418278 336.418278,660 332,660 L252,660 C247.581722,660 244,656.418278 244,652 L244,540 C244,535.581722 247.581722,532 252,532 L332,532 Z M580,548 C553.490332,548 532,569.490332 532,596 C532,622.509668 553.490332,644 580,644 C606.509668,644 628,622.509668 628,596 C628,569.490332 606.509668,548 580,548 Z M461,548 L444,548 C417.490332,548 396,569.490332 396,596 C396,622.509668 417.490332,644 444,644 L461,644 L461,548 Z M444,364 C479.346224,364 508,392.653776 508,428 C508,463.346224 479.346224,492 444,492 C408.653776,492 380,463.346224 380,428 C380,392.653776 408.653776,364 444,364 Z M332,364 C336.418278,364 340,367.581722 340,372 C340,376.418278 336.418278,380 332,380 L308,380 C281.490332,380 260,401.490332 260,428 C260,454.509668 281.490332,476 308,476 L332,476 C336.418278,476 340,479.581722 340,484 C340,488.418278 336.418278,492 332,492 L308,492 C272.653776,492 244,463.346224 244,428 C244,392.653776 272.653776,364 308,364 L332,364 Z M580,364 C615.346224,364 644,392.653776 644,428 C644,463.346224 615.346224,492 580,492 L556,492 C551.581722,492 548,488.418278 548,484 L548,372 C548,367.581722 551.581722,364 556,364 L580,364 Z M772,364 C776.418278,364 780,367.581722 780,372 C780,376.418278 776.418278,380 772,380 L700,380 L700,420 L772,420 C776.418278,420 780,423.581722 780,428 C780,432.418278 776.418278,436 772,436 L700,436 L700,476 L772,476 C776.418278,476 780,479.581722 780,484 C780,488.418278 776.418278,492 772,492 L692,492 C687.581722,492 684,488.418278 684,484 L684,372 C684,367.581722 687.581722,364 692,364 L772,364 Z M444,380 C417.490332,380 396,401.490332 396,428 C396,454.509668 417.490332,476 444,476 C470.509668,476 492,454.509668 492,428 C492,401.490332 470.509668,380 444,380 Z M580,380 L563,380 L563,476 L580,476 C606.509668,476 628,454.509668 628,428 C628,401.490332 606.509668,380 580,380 Z"></path></g></svg></a></div><div id="-codedoc-container" class="container"><h1 id="path-tracing" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Path Tracing</h1><h2 id="problem-statement" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Problem Statement</h2><p>Perform a theoretical investigation of some visibility algorithm or global illumination method.</p><h2 id="background" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Background</h2><p>Path Tracing was the first general-purpose unbiased Monte Carlo light transport algorithm introduced by Kajiya in 1986 that is used in graphics. It is similar to ray tracing in which rays are cast from a virtual camera and traced through a simulated scene. the light rays are reduced by a BRDF (Bidirectional Reflectance Distribution Function) to define how much of it will go towards the camera. This step is repeated for each pixel in the final image.</p><marker><p align="center">
  <img src="../sketches/path_tracing/path.svg" width="450" height="450">
</p>

</marker><p> Path tracing uses random sampling to incrementally compute a final image. The random sampling process makes it possible to render some complex phenomena which are not handled in regular ray tracing, but it generally takes longer time to produce a high quality path traced image. The random sampling in path tracing causes noise to appear in the rendered image. The noise is removed by letting the algorithm generate more samples, i.e. color values resulting from a single ray. Unlike other methods, path tracing replicate real behaviours than other alternatives don't integrate  natively like blur, ambient occlusion, depth of field and shadows.</p><marker><p align="center">
  <img src="../sketches/path_tracing/path_tracing_iterations.png">
</p>

</marker><h2 id="samples-per-pixel-spp" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Samples Per Pixel (SPP)</h2><p>The number of samples per pixel (SPP) is the defining factor for render quality. The higher SPP in a rendered image the less noise will be noticeable. However the added quality per sample decreases the more samples you have already (since each sample is just contributing to an average over all samples). The difference in image quality between, for instance, 20,000 SSP and 21,000 SSP will not be as noticeable as between 1,000 SSP and 2,000 SSP.</p><marker><p align="center">
  <img src="../sketches/path_tracing/spp.gif">
</p>

</marker><h2 id="global-illumination" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Global Illumination</h2><p> we see things because light emitted by light sources such as the sun bounces off of the surface of objects. When light rays bounce only once from the surface of an object to reach the eye, we speak of <strong>direct illumination</strong>. But when light rays are emitted by a light source, they can bounce off of the surface of objects multiple times before reaching the eye. This is what we call <strong>indirect illumination</strong> because light rays follow complex paths before entering the eye.</p><marker><p align="center">
  <img src="../sketches/path_tracing/illumination.png">
</p>


</marker><h2 id="backward-tracing" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Backward Tracing</h2><p>It is hard to come with a generic solution that solves all light paths: light rays can interact with many different kind of materials before entering the eye. As you know, in the real world, light travels from light sources to the eye. Simulating the path of a light ray as it interacts with various materials is thus something that we can easily do with a computer. Though the problem is that forward tracing in computer graphics is not an efficient way of making up an image. For this reason is prefered <strong>Backward Tracing</strong> which consists of tracing the path of light rays from the eye, back to the light source where they originated from.</p><marker><p align="center">
  <img src="../sketches/path_tracing/path.svg" width="450" height="450">
</p>

</marker><h3 id="indirect-lighting" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Indirect Lighting</h3><p>Light illuminating a given point P on the surface of an object, can come from all possible directions contained within a hemisphere oriented about the surface normal N at P. When dealing with direct light sources, finding where light comes from is simple. We just need to loop over all the light sources contained in the scene and either consider their direction if it is a directional light or trace a line from the light source to P if the light is a spherical or point light source. </p><marker><p align="center">
  <img src="../sketches/path_tracing/illumination_bounces2.png">
</p>

</marker><p>Though when we want to account for indirect lighting, every surface above P may redirect light towards P. Though,finding the direction of light rays when you deal with delta lights is simple but how do we do that when light is emitted by a surface? There is no unique point light position from which the light direction can be computed. A simple aproximation to deal with this problem is the <strong>Monte Carlo Integration</strong>. For this situation the algorithm  gather all light come from all possible directions above the hempisphere oriented about the normal at P. It is represented with the next integral:</p><p>gather light=∫ΩLi.
Gather Light≈1N∑n=0N castRay(P, randomDirectonAboveP) .</p><p>It is based on the idea that you can approximate or estimate how much light is redirected towards P by other objects in the scene, by casting rays from P in random directions above the surface and evaluating the color of the objects these rays intersect. The "quality" of this approximation mostly depends on N, the number of samples used. The higher N, the more likely you are to get a result close to the actual result of this integral.</p><p>Remember that what we want, is to collect all light reflected towards P by objects in the scene, which we can write with the integral described before. The variable Ω here, represents the hemisphere of directions oriented around the normal at P. This is the equation we are trying to solve and to get an approximation of this integral using Monte Carlo integration, we need to "sample" the function on the right side of the integral sign (the ∫ symbol), the Li term.</p><marker><p align="center">
  <img src="../sketches/path_tracing/function.png">
</p>



</marker><h4 id="sampling" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Sampling</h4><p>Since we need to account for the fact that light can come from anywhere above P, what we do instead in the case of Monte Carlo integration, is to select some random directions within the hemisphere oriented about P and trace rays in these directions into the scene. If these rays intersect some geometry in the scene, we then compute the object color at the intersected point which we assume to be the amount of light that the intersected object reflects towards P along the direction defined by the ray.</p><h3 id="algorithm" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Algorithm</h3><h4 id="step-1" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Step 1</h4><p>Select a random location in the half disk of the unit circle which we can do by simply drawing a random value for the angle θ anywhere in the range [0,π].</p><marker><p align="center">
  <img src="../sketches/path_tracing/step1.png">
</p>

</marker><h4 id="step-2" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Step 2</h4><p>Construct a 2x2 matrix using the shaded point normal and an interesting property of 2D vectors: a 2D cartesian coordinate system can be created from (Vx,Vy) and from (Vy,−Vx)</p><marker><p align="center">
  <img src="../sketches/path_tracing/step2.png">
</p>

</marker><h4 id="step-3" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Step 3</h4><p>Trace a ray in the sampled direction to find out if the ray that we just sampled hits an object in the scene. If it does, we then compute the color at the point of intersection which we assume to be the amount of light the intersected object reflects towards P along the ray direction.</p><marker><p align="center">
  <img src="../sketches/path_tracing/step3.png">
</p>

</marker><h4 id="step-4" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Step 4</h4><p>Multiply the object color at the ray intersection point by the cosine of the angle between the surface normal N and the light direction</p><marker><p align="center">
  <img src="../sketches/path_tracing/step4.png">
</p>

</marker><h4 id="step-5" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Step 5</h4><p>Accumulate the contribution of the sample.</p><h4 id="step-6" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Step 6</h4><p>The Monte Carlo integration equation tells us we need to divide the sum of the samples contribution by the sample size, the number N.</p><marker><p align="center">
  <img src="../sketches/path_tracing/step6.png">
</p>

</marker><h4 id="step-7" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Step 7</h4><p> accumulate the diffuse color of the object at P due to direct and indirect illumination and multiply the sum of these two values by the object.</p><marker><p align="center">
  <img src="../sketches/path_tracing/bounces.png">
</p>



</marker><h2 id="references" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>References</h2><ul><li><a href="http://www.graphics.stanford.edu/courses/cs348b-01/course29.hanrahan.pdf">http://www.graphics.stanford.edu/courses/cs348b-01/course29.hanrahan.pdf</a></li><li><a href="https://www.online-tech-tips.com/computer-tips/what-is-path-tracing-and-ray-tracing-and-why-do-they-improve-graphics/">https://www.online-tech-tips.com/computer-tips/what-is-path-tracing-and-ray-tracing-and-why-do-they-improve-graphics/</a></li><li><a href="https://www.pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Path_Tracing">https://www.pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Path_Tracing</a></li><li><a href="https://chunky.llbit.se/path_tracing.html">https://chunky.llbit.se/path_tracing.html</a></li></ul><div class="contentnav-0-0-10" data-no-search=""><a href="#path-tracing" class="h1" data-content-highlight="path-tracing">Path Tracing</a><a href="#problem-statement" class="h2" data-content-highlight="problem-statement">Problem Statement</a><a href="#background" class="h2" data-content-highlight="background">Background</a><a href="#samples-per-pixel-spp" class="h2" data-content-highlight="samples-per-pixel-spp">Samples Per Pixel (SPP)</a><a href="#global-illumination" class="h2" data-content-highlight="global-illumination">Global Illumination</a><a href="#backward-tracing" class="h2" data-content-highlight="backward-tracing">Backward Tracing</a><a href="#indirect-lighting" class="h3" data-content-highlight="indirect-lighting">Indirect Lighting</a><a href="#sampling" class="h4" data-content-highlight="sampling">Sampling</a><a href="#algorithm" class="h3" data-content-highlight="algorithm">Algorithm</a><a href="#step-1" class="h4" data-content-highlight="step-1">Step 1</a><a href="#step-2" class="h4" data-content-highlight="step-2">Step 2</a><a href="#step-3" class="h4" data-content-highlight="step-3">Step 3</a><a href="#step-4" class="h4" data-content-highlight="step-4">Step 4</a><a href="#step-5" class="h4" data-content-highlight="step-5">Step 5</a><a href="#step-6" class="h4" data-content-highlight="step-6">Step 6</a><a href="#step-7" class="h4" data-content-highlight="step-7">Step 7</a><a href="#references" class="h2" data-content-highlight="references">References</a></div></div><div id="-codedoc-toc" class="toc-0-0-7"><div class="content-0-0-8"></div><div class="search-0-0-9"><script id="wsucYhwKIS">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("wsucYhwKIS", "MChpnTvN8BpuKyiMGzmSYw==", {"repo":"vc","user":"afsanchezsa","root":"docs/md","pick":"\\.md$","drop":"(^_)|(\\/_)"});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script></div></div><div class="footer-0-0-6"><div class="left"><script id="fXzlZMWMKW">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("fXzlZMWMKW", "X5W7He+ge/Kg3B6xB+T5gg==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script></div><div class="main"><div class="inside"><a href="https://github.com/afsanchezsa/vc/" target="_blank">GitHub</a></div></div><div class="right"><script id="pdAutRgEBL">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("pdAutRgEBL", "3ehN2Qj7wHC4donAKEDe0Q==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script></div></div><script id="BUnUbujNZJ">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("BUnUbujNZJ", "bIAidu6MCPVPBcGGWLCR6Q==", {"namespace":"/vc"});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script></body></html>