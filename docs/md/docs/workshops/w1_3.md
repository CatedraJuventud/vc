## ASCII ART

*ASCII art* is a graphic design technique that uses computer characters for presentation and consists of pictures pieced together from some printable characters defined by the ASCII Standard. 

ASCII art was invented very early on because early printers often lacked graphics ability and thus characters were used in place of graphic marks. Other common uses were marking divisions between different print jobs from different users, and large banners. 

### Objective
Create an image composed solely of ASCII characters that looks like the original image. 

### Methodology
One of the (first) things to do when developing software is to devise which are the steps the program should take in order to achieve the desired outcome. To make ASCII art, each pixel or region of pixels from the original image must be mapped to a certain character. First, the image is converted to grayscale and then the program chooses a pixel that has a similar grayness. For example, a very dark pixel can be mapped to the character '#' or '$' which are dark, whereas a white pixel can become a dot '.' or a blanck space ' '. 


It is better to use a method that preserves the luminance of the original image in the grayscale image. This is the purpose of the [luma weighted sum](https://en.wikipedia.org/wiki/HSL_and_HSV#Lightness) where each pixel’s intensity or grey value is simply the weighted sum of the values of its RGB components computed as follows: 

> :Formula align=center
>
> ```
> Y_{706} = 0.2126 * R + 0.7152 * G + 0.0722 * B \\
> ```

Another good thing to do before applying luma is increasing the contrast of the image. That way the color range of the image increases and more characters get selected. This creates a nicer and sharper image. 

In short, the image passed trough a high contrast filter, then the luma weighted sum is applyed and finally the image gets mapped pixel by pixel to a character of similar brightness.

![Process](../sketches/workshop1/w3/explanation.png)

### Implementation
This program is written in ```javascrip``` and uses a very powerfull drawing library called [p5.js](https://p5js.org).

#### Contrast Adjustment
The contrast of an image is the difference between the maximum and minimum pixel intensity, the “amount” of separation between its darkest and brightest areas. It is then determined by the colour and brightness of the different objects or shapes that appear in the image. This means that the higher the contrast, the bigger the difference between pixel intensities, and the easier it will be to recognize the different objects in the image (due to this bigger range of intensities). The code was based on [Cassie's implementation](https://editor.p5js.org/cassie/sketches/SB4pBjns0).

```javascript
/**
 * Function based on https://editor.p5js.org/cassie/sketches/SB4pBjns0
 * 
 * @param {*} img image to be processed. Function changes the same reference to image 
 * @param {*} contrast 0 to 100
 */
function applyContrast(img, contrast) {
  img.loadPixels();
  for (let x = 0; x < img.width; x +=1) {
    for (let y = 0; y < img.height; y +=1) {
      let c = img.get(x,y);
      let factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
      let nR = constrain(factor*(red(c)-128) + 128, 0, 255);
      let nG = constrain(factor*(green(c)-128) + 128, 0, 255);
      let nB = constrain(factor*(blue(c)-128) + 128, 0, 255);
      let nC = color(nR,nG,nB);
      img.set(x,y,nC);
    }
  }
  img.updatePixels();
}
```

#### Grayscale conversion

The function takes an image and applies the ```luma_Y``` inline function to every pixel of the image. After that, it returns the luma brightness index per pixel. The funtion also returns the maximum (white pixel) and minimum (black pixel) possible values of brightness. These values are going to be used in the next step to map grayscale values to ASCII characters.

```javascript
/**
 * Applies luma to every pixel of given image
 * @param {*} img : image to be processed. Function changes the same reference to image 
 * @returns 
 */
function applyLuma (img){
  let lumaMatrix = []; // Stores luma values in matrix : [[row1], [row2], ..., [rowN]]

  let luma_Y = (pixel) => 0.2126 * red(pixel) + 0.7152 * green(pixel) + 0.0722 * blue(pixel);
  img.loadPixels();
  for (let j = 0; j < img.height; j++) {
    let row = [] // Single row of the matrix
    for (let i = 0; i < img.width; i++) {
      row.push(luma_Y(img.get(i, j))); // Apply luma to every pixel in image
    }
    lumaMatrix.push(row); 
  }
  return { 
    values: lumaMatrix ,
    minValue: luma_Y(color(0, 0, 0)), // Used for mapPixelToASCII
    maxValue: luma_Y(color(255, 255, 255)) // Used in mapPixelToASCII
  }
}
```


[//]: # "> :P5 sketch=/docs/sketches/workshop1/w3/preprocess.js, width=775, height=255"

[//]: # "> :P5 sketch=/docs/sketches/workshop1/w3/asciiart.js, width=800, height=900"

